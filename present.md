# python-konzepte-praesentation
# üêç Python Concepts ‚Äì Beginner Presentation (No Code)

This is a beginner-friendly overview of five fundamental Python programming concepts.  
Each includes a summary of its purpose, main advantages, and limitations.  
This presentation is **code-free**, designed for easy learning, teaching, or revising.

---

## üß≠ Topics Overview:

1. [ Bubble Sort](#1--bubble-sort)
2. [Arrays (Lists)](#2--arrays-lists)
3. [ Shortest Path (Dijkstra)](#3--shortest-path-dijkstra)
4. [ AVL Trees](#4--avl-trees)
5. [ Hash Sets (set)](#5--hash-sets-python-sets)

---

## 1. üîÅ Bubble Sort

** Purpose:**  
Bubble sort is a simple sorting algorithm that compares and swaps adjacent values.  
It‚Äôs mainly used for **educational purposes** to explain sorting logic.

** Advantages:**
- Very easy to understand and implement
- Great for learning how sorting works

** Disadvantages:**
- Extremely inefficient for large datasets (Time complexity: O(n¬≤))
- Rarely used in practice

---

## 2.  Arrays (Lists)

** Purpose:**  
Arrays (called **lists** in Python) are used to store multiple values in a single variable.  
They're **ordered**, **dynamic**, and support many operations.

** Advantages:**
- Fast access to elements using index
- Easy to modify, append, and iterate
- Flexible in size compared to traditional arrays

** Disadvantages:**
- Slower when inserting/deleting in the middle
- Not optimized for large-scale data manipulation

---

## 3. üó∫ Shortest Path (Dijkstra)

** Purpose:**  
Dijkstra's algorithm finds the **shortest path** from one node to all others in a graph ‚Äî useful in **navigation**, **networks**, and **optimization problems**.

** Advantages:**
- Guarantees the shortest path for non-negative edge weights
- Efficient and widely used in real-world systems

** Disadvantages:**
- Doesn‚Äôt support negative edge weights
- Can be memory-intensive on huge graphs

---

## 4.  AVL Trees

** Purpose:**  
AVL Trees are a type of **self-balancing binary search tree** that maintains balance after insertions/deletions, ensuring fast access and consistent performance.

** Advantages:**
- Guaranteed logarithmic time complexity (O(log n)) for search, insert, delete
- Always balanced ‚Üí no performance degradation

** Disadvantages:**
- More complex to implement than simple binary trees
- Rotations add additional overhead when modifying the tree

---

## 5. Hash Sets (Python `set`)

** Purpose:**  
Hash sets store **unique**, unordered elements. Ideal for checking **if an item exists**, filtering duplicates, or fast membership tests.

** Advantages:**
- xtremely fast lookups, insertions, and removals (average O(1))
- Automatically removes duplicates

** Disadvantages:**
- no order: items are not indexed
- Not suitable when element order matters

---



