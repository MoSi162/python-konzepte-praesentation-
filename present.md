# python-konzepte-praesentation
# Python Concepts â€“ Beginner Presentation 

This is a beginner-friendly "try to be bashar for one day" presentation 
in case of mistakes keep them as your personal secret ðŸ¤“
---

## Topics Overview:

1. [ Bubble Sort](#1--bubble-sort)
2. [Arrays (Lists)](#2--arrays-lists)
3. [ Shortest Path (Dijkstra)](#3--shortest-path-dijkstra)
4. [ AVL Trees](#4--avl-trees)
5. [ Hash Sets (set)](#5--hash-sets-python-sets)

---

## 1. Bubble Sort

** Purpose:**  
Bubble sort is a simple sorting algorithm that compares and swaps adjacent values.  
Itâ€™s mainly used for **educational purposes** to explain sorting logic.

** Advantages:**
- Very easy to understand and implement
- Great for learning how sorting works

** Disadvantages:**
- Extremely inefficient for large datasets (Time complexity: O(nÂ²))
- Rarely used in practice

---

## 2.  Arrays (Lists)

** Purpose:**  
Arrays (called **lists** in Python) are used to store multiple values in a single variable.  
They're **ordered**, **dynamic**, and support many operations.

** Advantages:**
- Fast access to elements using index
- Easy to modify, append, and iterate
- Flexible in size compared to traditional arrays

** Disadvantages:**
- Slower when inserting/deleting in the middle
- Not optimized for large-scale data manipulation

---

## 3.  Shortest Path (Dijkstra)

** Purpose:**  
Dijkstra's algorithm finds the **shortest path** from one node to all others in a graph â€” useful in **navigation**, **networks**, and **optimization problems**.

** Advantages:**
- Guarantees the shortest path for non-negative edge weights
- Efficient and widely used in real-world systems

** Disadvantages:**
- Doesnâ€™t support negative edge weights
- Can be memory-intensive on huge graphs

---

## 4.  AVL Trees

** Purpose:**  
AVL Trees are a type of **self-balancing binary search tree** that maintains balance after insertions/deletions, ensuring fast access and consistent performance.

** Advantages:**
- Guaranteed logarithmic time complexity (O(log n)) for search, insert, delete
- Always balanced â†’ no performance degradation

** Disadvantages:**
- More complex to implement than simple binary trees
- Rotations add additional overhead when modifying the tree

---

## 5. Hash Sets (Python `set`)

** Purpose:**  
Hash sets store **unique**, unordered elements. Ideal for checking **if an item exists**, filtering duplicates, or fast membership tests.

** Advantages:**
- xtremely fast lookups, insertions, and removals (average O(1))
- Automatically removes duplicates

** Disadvantages:**
- no order: items are not indexed
- Not suitable when element order matters

---



